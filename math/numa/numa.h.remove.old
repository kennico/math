#pragma once
#include <iterator>
#include <vector>
#include <algorithm>
#include <list>

#include "utils.h"

namespace knylaw {
namespace math {

    template<typename Numeric>
    struct Point {

        Numeric x, y;
    };

    template<typename Numeric>
    struct Xgeter {
        inline Numeric operator()(const Point<Numeric>& coord) const {
            return coord.x;
        }
    };

    template<typename Numeric>
    struct Ygeter {
        inline Numeric operator()(const Point<Numeric>& coord) const {
            return coord.y;
        }
    };

    template<typename Coord> struct CoordTraits;

    template<typename Float> struct CoordTraits<Point<Float>> {
        using Numeric = Float;
        using Xgeter = Xgeter<Numeric>;
        using Ygeter = Ygeter<Numeric>;
    };

    template<typename Float>
    struct Pointd : public Point<Float> {
        Numeric d;
    };

    namespace impl {

        template<typename Elem,
            typename Cont=std::vector<Elem>>
        class Data {

        public:

            using Container = Cont;

        public:
            //
            // https://stackoverflow.com/questions/13576055/how-is-default-different-from-for-default-constructor-and-destructor
            // 
            // Using a default constructor keeps abstract subclass
            // free from writing its own explicit constructor.
            //
            Data() = default;

        protected:
            //
            // this constructor may be redundant because a default one 
            // and the "accpet" function below are provided.
            //
            Data(const Container& container) : Mdata(container) {

            }

            //
            // subclass has no way but calling this function to change underlying content.
            //
            inline void accept(const Container& contianer) {
                this->Mdata = contianer;
            }

        public:

            ~Data() = default; 

            inline size_t count() const {
                return Mdata.size();
            }

            inline const Elem& data(size_t pos) const {
                return Mdata[pos];
            }

            inline const Cont& data() const {
                return Mdata;
            }

        private:
            Cont Mdata;

        };

        template<typename Element>
        class IntrplBaseType: 
            virtual public Data<Element> {
        public:

            using Input = Element;

            inline size_t N() const {
                return count() - 1;
            }

        };

        template<typename Coord,
            typename Traits = CoordTraits<Coord>>
        class Coord2dBaseType 
            :virtual public Data<Coord> {

        public:
            using Numeric = typename Traits::Numeric;
            
            inline Numeric X(size_t pos) const {
                return Mgetx(data(pos));
            }

            inline Numeric Y(size_t pos) const {
                return Mgety(data(pos));
            }

        private:

            typename Traits::Xgeter Mgetx; // require operator()(Input) overloading to get x
            typename Traits::Ygeter Mgety; // require operator()(Input) overloading to get y

        };
                
    }

    
    


    
}
}